---
import type { ComponentProps } from "astro/types";

import { getImage } from "astro:assets";
import { getCollection, getEntry } from "astro:content";

import type { SurprisesByTeamChartDatapoint } from "../components/charts/surprises-by-team";
import type { TeamCode } from "../content/utils";

import SurprisesByTeamChart from "../components/charts/surprises-by-team";
import SurprisesPerSeasonChart from "../components/charts/surprises-per-season";
import TeamSeasonScatterPlot from "../components/charts/team-season-scatter";
import Link from "../components/link.astro";
import Logo from "../components/logo.astro";
import Popover from "../components/popover";
import Table from "../components/table.astro";
import * as ContentUtils from "../content/utils";
import Subpage from "../layouts/subpage.astro";
import * as Utils from "../utils";

/* All-time Top 10 Table */

const teamSeasons = await getCollection("teamSeasons");
const paceArchive = [];
for (const teamSeason of teamSeasons) {
  const gamesPlayed = await getCollection("games", ({ data }) => {
    return (
      data.seasonId === teamSeason.data.season.id &&
      data.teams.map(({ teamId }) => teamId).includes(teamSeason.data.team.id)
    );
  });
  const record = ContentUtils.calculateTeamRecord(
    teamSeason.data.team.id,
    gamesPlayed.map((g) => g.data),
  );

  paceArchive.push({
    pace: await ContentUtils.pace(teamSeason, record),
    record,
    teamSeason,
  });
}

const paceTop10 = paceArchive.toSorted((a, b) => b.pace - a.pace).slice(0, 10);
const tableRows = [];
for (const paceEntry of paceTop10) {
  const team = await getEntry(paceEntry.teamSeason.data.team);

  const img = await getImage({
    src: ContentUtils.getTeamSeasonLogo(
      team,
      paceEntry.teamSeason.data.season.id,
    ),
  });

  tableRows.push({
    isSurpriseTeam: await ContentUtils.isSurprise(
      paceEntry.teamSeason,
      paceEntry.record,
    ),
    logoSrc: img.src,
    pace: paceEntry.pace,
    seasonRange: ContentUtils.abbreviateSeasonRange(
      await getEntry(paceEntry.teamSeason.data.season),
      {
        compact: true,
      },
    ),
    team,
    teamName: ContentUtils.resolveTeamName(
      team,
      paceEntry.teamSeason.data.season.id,
    ),
    teamSeason: paceEntry.teamSeason,
  });
}

/* END All-time Top 10 Table */

/* Surprises per Season chart */

const surprisesPerSeason: ComponentProps<
  typeof SurprisesPerSeasonChart
>["data"] = [];

const seasons = await getCollection("seasons");

for (const season of seasons) {
  const gamesInSeason = await getCollection("games", ({ data }) => {
    return data.seasonId === season.id;
  });

  const teamSeasonsInSeason = await getCollection("teamSeasons", ({ data }) => {
    return data.season.id === season.id;
  });

  const datapoint = {
    numSurprises: 0,
    seasonId: season.id,
    seasonRange: ContentUtils.abbreviateSeasonRange(season, {
      compact: true,
    }),
    // TODO Why does this need to be typed? Why is it initialized to never[]?
    surpriseTeams: [] as ComponentProps<
      typeof SurprisesPerSeasonChart
    >["data"][number]["surpriseTeams"],
  };

  for (const teamSeason of teamSeasonsInSeason) {
    const record = ContentUtils.calculateTeamRecord(
      teamSeason.data.team.id,
      gamesInSeason.map((game) => game.data),
    );
    const isSurpriseTeam = await ContentUtils.isSurprise(teamSeason, record);
    if (isSurpriseTeam) {
      const team = await getEntry(teamSeason.data.team);
      const img = await getImage({
        src: ContentUtils.getTeamSeasonLogo(team, teamSeason.data.season.id),
      });

      datapoint.numSurprises += 1;
      datapoint.surpriseTeams.push({
        logoSrc: img.src,
        name: ContentUtils.resolveTeamName(team, team.id),
        teamId: teamSeason.data.team.id as TeamCode,
      });
    }
  }

  datapoint.surpriseTeams.sort((a, b) => a.name.localeCompare(b.name));
}

// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
const latestSeason = (await ContentUtils.getLatestSeason())!;

/* END Surprises per Season chart */

/* Surprises by Team chart */

/* END Surprises by Team chart */

interface Datapoint extends ContentUtils.TeamStats {
  formattedPace: string;
  isSurpriseTeam: boolean;
  logoSrc: string;
  pace: ReturnType<typeof ContentUtils.pace>;
  seasonRange: string;
  teamName: string;
}

const statsId = (teamData: {
  seasonId: ContentUtils.TeamStats["data"]["seasonId"];
  teamId: ContentUtils.TeamStats["data"]["teamId"];
}) => {
  return `${teamData.seasonId}/${teamData.teamId}`;
};

// map of seasonId/teamId : Datapoint
const stats: Record<string, Datapoint> = {};

const archived = await ContentUtils.getArchivedSeasons();

for (const season of archived) {
  const teamSeasons = await ContentUtils.getTeamSeasonsBySeason(season.id);
  for (const teamSeason of teamSeasons) {
    stats[statsId(teamSeason.data)] = {
      ...teamSeason,
      isSurpriseTeam: false,
      pace: 0,
      record: { l: 0, w: 0 },
    } as Datapoint;
  }
}

const allGames = await ContentUtils.getCompleteDataset();

for (const game of allGames) {
  const [teamA, teamZ] = game.teams;

  for (const team of game.teams.filter(
    // verify team playing is a surprise candidate in the game's season
    async (tc) =>
      await ContentUtils.getTeamSeason(game.seasonId.toString(), tc.teamId),
  )) {
    const _id = statsId({ seasonId: game.seasonId, teamId: team.teamId });

    const you = team.teamId === teamA.teamId ? teamA : teamZ;
    const them = team.teamId === teamA.teamId ? teamZ : teamA;

    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    stats[_id]!.record[you.score > them.score ? "w" : "l"] += 1;
  }
}

const datapoints = Object.values(stats);

const surprisesBySeason = new Map(
  archived.map((season) => [
    season.id,
    [] as SurprisesPerSeasonChartDatapoint["teamSeasons"],
  ]),
);

for (const datapoint of datapoints) {
  const season = await ContentUtils.getSeasonById(datapoint.data.seasonId);
  if (!season) continue;

  const team = await ContentUtils.getTeamById(datapoint.data.teamId);
  if (!team) continue;

  datapoint.pace = ContentUtils.pace(datapoint, season);
  datapoint.isSurpriseTeam = ContentUtils.isSurprise(datapoint, season);
  datapoint.teamName = ContentUtils.resolveTeamName(
    datapoint.data.seasonId,
    team,
  );
  datapoint.seasonRange = ContentUtils.abbreviateSeasonRange(season, {
    compact: true,
  });
  datapoint.formattedPace = ContentUtils.formatPace(datapoint, season);

  const img = await getImage({
    src: ContentUtils.getTeamSeasonLogo(datapoint.data.seasonId, team),
  });

  datapoint.logoSrc = img.src;

  if (datapoint.isSurpriseTeam) {
    surprisesBySeason.get(datapoint.data.seasonId)?.push(datapoint);
  }
}

// @ts-expect-error: Object not instantiated with every team id, filled in below
const surprisesByTeam: Record<TeamCode, SurprisesByTeamChartDatapoint> = {};

for (const point of datapoints) {
  const team = await ContentUtils.getTeamById(point.data.teamId);
  const season = await ContentUtils.getSeasonById(point.data.seasonId);
  if (!team || !season) continue;

  const teamId = point.data.teamId;

  if (team.data.alternativeNames) {
    const img = await getImage({
      src: ContentUtils.getCurrentTeamLogo(team),
    });
    surprisesByTeam[point.data.teamId] ??= {
      logoSrc: img.src,
      numEliminated: 0,
      numSurprised: 0,
      teamId: point.data.teamId,
    };
  } else {
    const img = await getImage({
      src: ContentUtils.getCurrentTeamLogo(team),
    });
    surprisesByTeam[point.data.teamId] ??= {
      logoSrc: img.src,
      numEliminated: 0,
      numSurprised: 0,
      teamId: point.data.teamId,
    };
  }

  if (ContentUtils.isSurprise(point, season)) {
    surprisesByTeam[teamId].numSurprised += 1;
  }

  if (ContentUtils.isEliminated(point, season)) {
    surprisesByTeam[teamId].numEliminated += 1;
  }
}
---

<script>
  // Enlarge table contents while in non-mobile, single-column layout

  const mediaQueryList = globalThis.matchMedia(
    "(min-width: 640px) and (max-width: 1279px)",
  );

  function handleOrientationChange(ev: MediaQueryList | MediaQueryListEvent) {
    const table = document.querySelector("#top-10");
    if (ev.matches) {
      table?.classList.remove("compact");
    } else {
      table?.classList.add("compact");
    }
  }

  handleOrientationChange(mediaQueryList);
  mediaQueryList.addEventListener("change", handleOrientationChange);
</script>

<Subpage
  description="Stats and insights from surprise team history"
  title="Stats"
>
  <h1 class="font-title text-center text-2xl text-lime-400 md:text-4xl">
    Stats
  </h1>
  <div class="mt-16 grid gap-24 px-4 xl:grid-cols-2">
    <section class="order-2 xl:order-1">
      <h2 class="font-title mb-8 text-center text-lg text-lime-400 md:text-xl">
        Surprises x Season
      </h2>
      <SurprisesPerSeasonChart
        client:load
        data={surprisesPerSeason}
        latestSeasonYear={Number.parseInt(latestSeason?.id, 10)}
      />
    </section>

    <section class="order-1 max-md:-mx-4 xl:order-2">
      <h2 class="font-title mb-8 text-center text-lg text-lime-400 md:text-xl">
        All-Time Top 10
      </h2>
      <Table class="w-full" id="top-10">
        <Fragment slot="head">
          <tr>
            <td class="w-1/2"></td>
            <th class="md:w-1/3" scope="col">
              <span class="md:hidden">O/U</span>
              <span class="hidden md:inline">Over/Under</span>
            </th>
            <th class="relative text-right" scope="col">
              Pace
              <Popover client:load>
                <p class="mb-1 font-bold underline">Pace</p>
                <p>
                  Current Projected Wins - Wins needed to surprise (x (10 for
                  standard-length seasons) wins above a team's preseason
                  over/under (rounded up))
                </p>
              </Popover>
            </th>
          </tr>
        </Fragment>
        <Fragment slot="body">
          {
            tableRows.map((row) => {
              return (
                <tr>
                  <th scope="row">
                    <div class="flex flex-row items-center gap-4">
                      <Logo
                        loading="eager"
                        seasonId={row.teamSeason.data.season.id}
                        team={row.team}
                      />
                      <Link
                        class="relative"
                        href={`/${row.teamSeason.data.season.id}/${row.team.id}`}
                      >
                        <span class="hidden md:inline">
                          {row.teamName}
                          {row.seasonRange}
                        </span>
                        <span class="md:hidden">
                          {row.team.id}
                          {row.seasonRange}
                        </span>
                      </Link>
                    </div>
                  </th>
                  <td class="text-right">{row.teamSeason.data.overUnder}</td>
                  <td class="text-right">
                    {Utils.signedFormatter.format(row.pace)}{" "}
                  </td>
                </tr>
              );
            })
          }
        </Fragment>
      </Table>
    </section>

    <section class="order-3">
      <h2 class="font-title mb-8 text-center text-lg text-lime-400 md:text-xl">
        Surprises x Teams
      </h2>
      <SurprisesByTeamChart
        client:visible
        data={Object.values(surprisesByTeam)}
      />
    </section>

    <section class="order-4">
      <h2 class="font-title mb-8 text-center text-lg text-lime-400 md:text-xl">
        Pace x Over/Under
      </h2>
      <TeamSeasonScatterPlot client:visible data={datapoints} />
    </section>
  </div>
</Subpage>
